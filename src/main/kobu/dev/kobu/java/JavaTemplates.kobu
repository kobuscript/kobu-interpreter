/*
MIT License

Copyright (c) 2022 Luiz Mineo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

module dev.kobu.java.JavaTemplates

import dev.kobu.functions.TemplateFunctions
import dev.kobu.java.JavaOutputTypes

type template JavaMethodBodyTemplate

type template JavaMethodTemplate

def template JavaFileTemplate for OutputJavaFile as file
                              join AnyTemplate[] as defTmpl of file.definitions <|
${ifNotBlank(file.comment, () => file.comment + "\n")}package ${file.package};

${strJoin(file.imports, "\n", imp => "import " + imp + ";")}
${strJoin(defTmpl, "\n")}
|>

def template JavaClassTemplate for OutputJavaClass as class
                               join AnyTemplate[] as annTmpl of class.annotations
                               join JavaMethodTemplate[] as consTmpl of class.constructors
                               join JavaMethodTemplate[] as methodsTmpl of class.methods
                               join AnyTemplate[] as fieldsTmpl of class.fields
                               join AnyTemplate[] as innerClassesTmpl of class.innerClasses
                               join AnyTemplate[] as innerInterfacesTmpl of class.innerInterfaces
                               join AnyTemplate[] as innerEnumsTmpl of class.innerEnums
                               join AnyTemplate[] as innerRecordsTmpl of class.innerRecords <|
${ifNotBlank(class.comment, () => "\n" + class.comment)}
${strJoin(annTmpl, "\n")}
${getJavaClassSignature(class)} {
    ${strJoin(fieldsTmpl, "\n")}
    ${strJoin(consTmpl, "\n")}
    ${strJoin(methodsTmpl, "\n")}
    ${strJoin(innerClassesTmpl, "\n")}
    ${strJoin(innerInterfacesTmpl, "\n")}
    ${strJoin(innerEnumsTmpl, "\n")}
    ${strJoin(innerRecordsTmpl, "\n")}
}
|>

def template JavaInterfaceTemplate for OutputJavaInterface as interface
                               join AnyTemplate[] as annTmpl of interface.annotations
                               join JavaMethodTemplate[] as methodsTmpl of interface.methods
                               join AnyTemplate[] as fieldsTmpl of interface.fields
                               join AnyTemplate[] as innerClassesTmpl of interface.innerClasses
                               join AnyTemplate[] as innerInterfacesTmpl of interface.innerInterfaces
                               join AnyTemplate[] as innerEnumsTmpl of interface.innerEnums
                               join AnyTemplate[] as innerRecordsTmpl of interface.innerRecords <|
${ifNotBlank(interface.comment, () => "\n" + interface.comment)}
${strJoin(annTmpl, "\n")}
${getJavaInterfaceSignature(interface)} {
    ${strJoin(fieldsTmpl, "\n")}
    ${strJoin(methodsTmpl, "\n")}
    ${strJoin(innerClassesTmpl, "\n")}
    ${strJoin(innerInterfacesTmpl, "\n")}
    ${strJoin(innerEnumsTmpl, "\n")}
    ${strJoin(innerRecordsTmpl, "\n")}
}
|>

def template JavaEnumTemplate for OutputJavaEnum as javaEnum
                              join AnyTemplate[] as annTmpl of javaEnum.annotations
                              join AnyTemplate[] as valuesTmpl of javaEnum.values
                              join JavaMethodTemplate[] as consTmpl of javaEnum.constructors
                              join JavaMethodTemplate[] as methodsTmpl of javaEnum.methods
                              join AnyTemplate[] as fieldsTmpl of javaEnum.fields
                              join AnyTemplate[] as innerClassesTmpl of javaEnum.innerClasses
                              join AnyTemplate[] as innerInterfacesTmpl of javaEnum.innerInterfaces
                              join AnyTemplate[] as innerEnumsTmpl of javaEnum.innerEnums
                              join AnyTemplate[] as innerRecordsTmpl of javaEnum.innerRecords <|
${ifNotBlank(javaEnum.comment, () => "\n" + javaEnum.comment)}
${strJoin(annTmpl, "\n")}
${getJavaEnumSignature(javaEnum)} {
    ${mkString(valuesTmpl, "", ",\n", ";\n")}
    ${strJoin(fieldsTmpl, "\n")}
    ${strJoin(consTmpl, "\n")}
    ${strJoin(methodsTmpl, "\n")}
    ${strJoin(innerClassesTmpl, "\n")}
    ${strJoin(innerInterfacesTmpl, "\n")}
    ${strJoin(innerEnumsTmpl, "\n")}
    ${strJoin(innerRecordsTmpl, "\n")}
}
|>

def template JavaRecordTemplate for OutputJavaRecord as javaRecord
                                join AnyTemplate[] as annTmpl of javaRecord.annotations
                                join AnyTemplate[] as compTmpl of javaRecord.components
                                join JavaMethodTemplate[] as consTmpl of javaRecord.constructors
                                join JavaMethodTemplate[] as methodsTmpl of javaRecord.methods
                                join AnyTemplate[] as fieldsTmpl of javaRecord.fields
                                join AnyTemplate[] as innerClassesTmpl of javaRecord.innerClasses
                                join AnyTemplate[] as innerInterfacesTmpl of javaRecord.innerInterfaces
                                join AnyTemplate[] as innerEnumsTmpl of javaRecord.innerEnums
                                join AnyTemplate[] as innerRecordsTmpl of javaRecord.innerRecords <|
${ifNotBlank(javaRecord.comment, () => "\n" + javaRecord.comment)}
${strJoin(annTmpl, "\n")}
${getJavaRecordHeader(javaRecord)}(${strJoin(compTmpl, ",\n")})${getJavaRecordInterfaces(javaRecord)} {
    ${strJoin(fieldsTmpl, "\n")}
    ${strJoin(consTmpl, "\n")}
    ${strJoin(methodsTmpl, "\n")}
    ${strJoin(innerClassesTmpl, "\n")}
    ${strJoin(innerInterfacesTmpl, "\n")}
    ${strJoin(innerEnumsTmpl, "\n")}
    ${strJoin(innerRecordsTmpl, "\n")}
}
|>

def template JavaConstructorTemplate for OutputJavaClass as class / constructors[*] as cons
                                     join AnyTemplate[] as annTmpl of cons.annotations
                                     join AnyTemplate[] as paramTmpl of cons.parameters
                                     join JavaMethodBodyTemplate as body of cons <|
${ifNotBlank(cons.comment, () => "\n" + cons.comment)}
${strJoin(annTmpl, "\n")}
${getJavaConstructorHeader(class, cons)}(${strPartitionJoin(paramTmpl, 3, ", ", ",\n")}) {
    ${body}
}
|>

def template JavaAnnotationTemplate for OutputJavaAnnotationValue as ann
                                    join AnyTemplate[] as fieldsTmpl of ann.fields <|
@{ann.name}(
    ${strJoin(fieldsTmpl, ",\n")}
)
|>

def template JavaAnnotationSingleValueTemplate extends JavaAnnotationTemplate
                                               for OutputJavaAnnotationValue as ann
                                               join AnyTemplate[] as valuesTmpl of ann.fields.map(f => f.value)
                                               when ann.fields.size() == 1 and ann.fields[0].field == "value" <|
@${ann.name}($^{valuesTmpl[0]})
|>

def template avaAnnotationFieldValueTemplate for OutputJavaAnnotationFieldValue as field
                                             join AnyTemplate as valueTmpl of field.value <|
${field.field}=$^{valueTmpl}
|>



def template JavaArrayValueTemplate for OutputJavaArrayValue as arr
                                    join AnyTemplate[] as valuesTmpl of arr.value <|
{
    ${strJoin(valuesTmpl, ",\n")}
}
|>

def template JavaArrayLiteralValueTemplate extends JavaArrayValueTemplate
                                           for OutputJavaArrayValue as arr
                                           join AnyTemplate[] as valuesTmpl of arr.value
                                           when arr.value.every(v => v instanceof OutputLiteralJavaValue) <|
{${strJoin(valuesTmpl, ", ")}}
|>

def template JavaSourceValueTemplate for OutputJavaSource as javaSource <|
${javaSource.source}
|>

def template LiteralJavaValueTemplate for OutputLiteralJavaValue as javaValue <|
${javaValue.value}
|>

def template LiteralJavaStringTemplate extends LiteralJavaValueTemplate
                                       for OutputLiteralJavaValue as javaValue
                                       when javaValue.value instanceof string <|
"${(javaValue.value as string).escape()}"
|>

fun getJavaClassSignature(javaClass: OutputJavaClass): string {
    return mkString(javaClass.modifiers, "", " ", " ") +
            "class " + javaClass.name +
            mkString(javaClass.typeParameters, "<", ", ", ">") +
            ifNotBlank(javaClass.superType, () => " extends " + javaClass.superType) +
            mkString(javaClass.implements, " implements ", ", ", "")
}

fun getJavaInterfaceSignature(javaInterface: OutputJavaInterface): string {
    return mkString(javaInterface.modifiers, "", " ", " ") +
            "interface " + javaInterface.name +
            mkString(javaInterface.typeParameters, "<", ", ", ">") +
            mkString(javaInterface.superTypes, " extends ", ", ", "")
}

fun getJavaEnumSignature(javaEnum: OutputJavaEnum): string {
    return mkString(javaEnum.modifiers, "", " ", " ") +
            "enum " + javaEnum.name +
            mkString(javaEnum.implements, " implements ", ", ", "")
}

fun getJavaRecordHeader(javaRecord: OutputJavaRecord): string {
    return mkString(javaRecord.modifiers, "", " ", " ") +
            "record " + javaRecord.name +
            mkString(javaRecord.typeParameters, "<", ", ", ">")
}

fun getJavaRecordInterfaces(javaRecord: OutputJavaRecord): string {
    return mkString(javaRecord.implements, " implements ", ", ", "")
}

fun getJavaConstructorHeader(javaClass: OutputJavaClass, constructor: OutputJavaConstructor): string {
    return mkString(constructor.modifiers, "", " ", " ") +
           mkString(constructor.typeParameters, "<", ", ", "> ") +
           javaClass.name
}