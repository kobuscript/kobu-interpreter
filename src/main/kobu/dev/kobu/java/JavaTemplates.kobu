/*
MIT License

Copyright (c) 2022 Luiz Mineo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

module dev.kobu.java.JavaTemplates

import dev.kobu.functions.TemplateFunctions
import dev.kobu.java.JavaOutputTypes

type template JavaMethodBodyTemplate

type template JavaMethodTemplate

def template JavaFileTemplate for OutputJavaFile as file
                              join AnyTemplate[] as defTmpls of file.definitions <|
${ifNotBlank(file.comment, () => file.comment + "\n")}package ${file.package};

${strJoin(file.imports, "\n", imp => "import " + imp + ";")}
${strJoin(defTmpls, "\n")}
|>

def template JavaClassTemplate for OutputJavaClass as class
                               join AnyTemplate[] as annTmpls of class.annotations
                               join JavaMethodTemplate[] as consTmpls of class.constructors
                               join JavaMethodTemplate[] as methodsTmpls of class.methods
                               join AnyTemplate[] as fieldsTmpls of class.fields
                               join AnyTemplate[] as innerClassesTmpls of class.innerClasses
                               join AnyTemplate[] as innerInterfacesTmpls of class.innerInterfaces
                               join AnyTemplate[] as innerEnumsTmpls of class.innerEnums
                               join AnyTemplate[] as innerRecordsTmpls of class.innerRecords <|
${ifNotBlank(class.comment, () => "\n" + class.comment)}
${strJoin(annTmpls, "\n")}
${getJavaClassSignature(class)} {
    ${strJoin(fieldsTmpls, "\n")}
    ${strJoin(consTmpls, "\n")}
    ${strJoin(methodsTmpls, "\n")}
    ${strJoin(innerClassesTmpls, "\n")}
    ${strJoin(innerInterfacesTmpls, "\n")}
    ${strJoin(innerEnumsTmpls, "\n")}
    ${strJoin(innerRecordsTmpls, "\n")}
}
|>

def template JavaInterfaceTemplate for OutputJavaInterface as interface
                               join AnyTemplate[] as annTmpls of interface.annotations
                               join JavaMethodTemplate[] as methodsTmpls of interface.methods
                               join AnyTemplate[] as fieldsTmpls of interface.fields
                               join AnyTemplate[] as innerClassesTmpls of interface.innerClasses
                               join AnyTemplate[] as innerInterfacesTmpls of interface.innerInterfaces
                               join AnyTemplate[] as innerEnumsTmpls of interface.innerEnums
                               join AnyTemplate[] as innerRecordsTmpls of interface.innerRecords <|
${ifNotBlank(interface.comment, () => "\n" + interface.comment)}
${strJoin(annTmpls, "\n")}
${getJavaInterfaceSignature(interface)} {
    ${strJoin(fieldsTmpls, "\n")}
    ${strJoin(methodsTmpls, "\n")}
    ${strJoin(innerClassesTmpls, "\n")}
    ${strJoin(innerInterfacesTmpls, "\n")}
    ${strJoin(innerEnumsTmpls, "\n")}
    ${strJoin(innerRecordsTmpls, "\n")}
}
|>

def template JavaEnumTemplate for OutputJavaEnum as javaEnum
                              join AnyTemplate[] as annTmpls of javaEnum.annotations
                              join AnyTemplate[] as valuesTmpls of javaEnum.values
                              join JavaMethodTemplate[] as consTmpls of javaEnum.constructors
                              join JavaMethodTemplate[] as methodsTmpls of javaEnum.methods
                              join AnyTemplate[] as fieldsTmpls of javaEnum.fields
                              join AnyTemplate[] as innerClassesTmpls of javaEnum.innerClasses
                              join AnyTemplate[] as innerInterfacesTmpls of javaEnum.innerInterfaces
                              join AnyTemplate[] as innerEnumsTmpls of javaEnum.innerEnums
                              join AnyTemplate[] as innerRecordsTmpls of javaEnum.innerRecords <|
${ifNotBlank(javaEnum.comment, () => "\n" + javaEnum.comment)}
${strJoin(annTmpls, "\n")}
${getJavaEnumSignature(javaEnum)} {
    ${mkString(valuesTmpls, "", ",\n", ";\n")}
    ${strJoin(fieldsTmpls, "\n")}
    ${strJoin(consTmpls, "\n")}
    ${strJoin(methodsTmpls, "\n")}
    ${strJoin(innerClassesTmpls, "\n")}
    ${strJoin(innerInterfacesTmpls, "\n")}
    ${strJoin(innerEnumsTmpls, "\n")}
    ${strJoin(innerRecordsTmpls, "\n")}
}
|>

fun getJavaClassSignature(javaClass: OutputJavaClass): string {
    return mkString(javaClass.modifiers, "", " ", " ") +
            "class " + javaClass.name +
            mkString(javaClass.typeParameters, "<", ", ", ">") +
            ifNotBlank(javaClass.superType, () => " extends " + javaClass.superType) +
            mkString(javaClass.implements, " implements ", ", ", "")
}

fun getJavaInterfaceSignature(javaInterface: OutputJavaInterface): string {
    return mkString(javaInterface.modifiers, "", " ", " ") +
            "interface " + javaInterface.name +
            mkString(javaInterface.typeParameters, "<", ", ", ">") +
            mkString(javaInterface.superTypes, " extends ", ", ", "")
}

fun getJavaEnumSignature(javaEnum: OutputJavaEnum): string {
    return mkString(javaEnum.modifiers, "", " ", " ") +
            "enum " + javaEnum.name +
            mkString(javaEnum.implements, " implements ", ", ", "")
}